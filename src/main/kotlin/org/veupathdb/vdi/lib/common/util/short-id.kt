@file:Suppress("SameParameterValue")
package org.veupathdb.vdi.lib.common.util

import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import org.veupathdb.vdi.lib.common.OriginTimestamp
import java.io.File
import kotlin.experimental.and
import kotlin.experimental.or
import kotlin.random.Random


object ShortID {
  private const val TieMax: Byte = 61

  private val TimestampOffset = OriginTimestamp.toEpochSecond()

  private val alphabet = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".encodeToByteArray()

  private val random = Random(System.nanoTime())

  private val lock = Mutex()

  private val wid = ByteArray(2) { alphabet[random.nextInt(61)] }

  private var now = timestamp()

  private var tieBreaker: Byte = 0

  @JvmStatic
  fun main(args: Array<String>) {
    val file = File("/home/ellie/ids.txt")

//    runBlocking { repeat(10) { println(generate()) } }

    file.bufferedWriter().use {
      runBlocking {
        for (i in 0..<1_000_000_000) {
          it.write(generate())
          it.newLine()
        }
      }
      it.flush()
    }
  }

  /**
   * Generates a 15 digit time-based identifier encoded in base-62.
   *
   * This identifier is constructed of the following parts:
   *
   * 1. A random 16-bit worker ID generated on class load.
   * 2. A tie-breaker, incremented if multiple IDs are generated within the same
   *    second.
   * 3. The number of seconds passed since [OriginTimestamp].
   * 4. 7 bytes of random data
   *
   * @return A new identifier string.
   */
  suspend fun generate(): String {
    var time = timestamp()
    var tbCopy: Byte

    lock.withLock {
      if (time == now) {
        if (tieBreaker == TieMax) {
          time++
          now = time
          tieBreaker = 0
        } else {
          tieBreaker++
        }
      } else {
        now = time
        tieBreaker = 0
      }

      tbCopy = tieBreaker
    }

    return String(weaveIdentifier(time, tbCopy))
  }

  /**
   * Upper mask is used to mask the individual bytes of input numbers when
   * encoding to string.
   *
   * ```
   * UpperMask | LowerMask == 61
   * ```
   */
  private const val LowerMask: Byte = 0x1D

  /**
   * Lower mask is used to mask randomly generated bytes to be added to the
   * individual bytes of input numbers when encoding to string.
   *
   * ```
   * UpperMask | LowerMask == 61
   * ```
   */
  private const val UpperMask: Byte = 0x3C

  /**
   * Encodes the given timestamp as a randomized base62 encoded chunk of 8 bytes
   * into the given byte array.
   *
   * @param value Timestamp in seconds since VDI origin.
   *
   * @param into Byte array the encoded timestamp will be written to.
   */
  private fun encodeTime(value: UInt, into: ByteArray, offset: Int) {
    val e = offset+8
    // Generate some random bytes
    random.nextBytes(into, offset, e)
    for (i in offset..<e)
      into[i] = alphabet[
        // take the original value and shift it right by the current index (0-7)
        value.shr(i-offset).toByte()
          // mask it with the alphabet mask (lower half)
          .and(LowerMask)
          // add in the random byte masked with the upper alphabet mask
          .or(into[i].and(UpperMask))
          // convert to an index in the alphabet array
          .toInt()
      ]
  }

  private const val PosMask: Byte = 0x7F

  private fun encodeRandom(into: ByteArray, offset: Int) {
    val e = offset+4
    random.nextBytes(into, offset, e)
    for (i in offset ..< e) {
      if (into[i] < 0)
        into[i] = into[i].and(PosMask)

      var a = into[i].toInt()

      while (a > 61)
        a = a.shr(1)

      into[i] = alphabet[a]
    }
  }

  /**
   * Convenience const to avoid having to cast to UInt a bunch of times.
   */
  private const val UMask = 61u

  /**
   * ID component byte ordering.
   *
   * Controls what parts of the generated ID appear in what position in the
   * output string with each array element representing the string character
   * index.
   *
   * **WARNING**: These values have been intentionally organized by hand to
   * control the output ID structure.  This ordering MUST NOT be changed in
   * order to maintain uniqueness.
   */
  private val ByteOrder = intArrayOf(
    // 2 worker id bytes (big endian) only changes on service restart
    12,
    10,
    // tie-breaker
    7,
    // 6 timestamp bytes (little endian)
    1,
    6,
    4,
    13,
    5,
    8,
    // 7 random bytes
    2,
    9,
    14,
    0,
    3,
    15,
    11,
  )

  private fun weaveIdentifier(timestamp: UInt, tieBreaker: Byte): ByteArray {
    val tsi = timestamp.toInt() // this will flip the int to negative, use ushr
    val out = random.nextBytes(ByteArray(16))
    var i = 0

    // [0]
    out[ByteOrder[i]]   = wid[0]
    out[ByteOrder[++i]] = wid[1]
    out[ByteOrder[++i]] = alphabet[tieBreaker.toInt()]

    // [3]
    // Shift the timestamp down 5 bits at a time, ignoring the greatest 2 bits.
    //
    // 31 is the greatest value we can use to avoid data loss in the encoding of
    // the timestamp.  The mask for 61 (the alphabet size) is 111101, meaning
    // there would be potential conflicts due to the 6 bits we would lose on
    // that zero when shifting down 6 at a time.
    out[ByteOrder[++i]] = alphabet[tsi.and(31)]
    out[ByteOrder[++i]] = alphabet[tsi.ushr(5).and(31)]
    out[ByteOrder[++i]] = alphabet[tsi.ushr(10).and(31)]
    out[ByteOrder[++i]] = alphabet[tsi.ushr(15).and(31)]
    out[ByteOrder[++i]] = alphabet[tsi.ushr(20).and(31)]
    out[ByteOrder[++i]] = alphabet[tsi.ushr(25).and(31)]

    // [9]
    // Fill the rest of the array with random bytes, then convert those bytes to
    // base62 alphabet chars.
    while (++i < out.size) {
      val j = ByteOrder[i]
      out[j] = alphabet[out[j].and(61).toInt()]
    }

    return out
  }

  private fun timestamp() = System.currentTimeMillis()
    .div(1000)              // to seconds
    .minus(TimestampOffset) // subtract origin timestamp
    .toUInt()
}
