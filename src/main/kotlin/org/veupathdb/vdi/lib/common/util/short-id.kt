package org.veupathdb.vdi.lib.common.util

import org.unbrokendome.base62.Base62
import java.nio.ByteBuffer
import java.util.Base64
import java.util.concurrent.locks.ReentrantLock
import kotlin.concurrent.withLock
import kotlin.random.Random

object ShortID {
  private val random = Random(System.nanoTime())

  private val miniLock = ReentrantLock()

  private var now = System.currentTimeMillis()

  private var miniCount: UShort = 0u

  /**
   * Generates an 11 digit time-based "mini" identifier encoded in base-62.
   *
   * This identifier is constructed of 3 parts:
   *
   * 1. 64 bits of random data.  This is to prevent conflicts between IDs
   *    generated by different service stacks on the same millisecond.
   * 2. 16 bits of "tie-breaker".  This is a counter that increments when more
   *    than one id is generated within a single millisecond.  If more than
   *    65535 IDs are generated in a millisecond, this method will pause for one
   *    millisecond to reset the tie-break counter.
   * 3. 40 bits of timestamp milliseconds.  This is to prevent ID conflicts over
   *    time for up to 35 years.
   *
   * @return A new random identifier string.
   */
  @JvmStatic
  fun generate(): String {
    var time = System.currentTimeMillis()

    miniLock.withLock {
      if (time == now) {
        if (miniCount == UShort.MAX_VALUE) {
          while (time == now) {
            Thread.sleep(1)
            time = System.currentTimeMillis()
          }
          now = time
          miniCount = 0u
        } else {
          miniCount++
        }
      } else {
        now = time
        miniCount = 0u
      }
    }

    val raw = ByteArray(15)
    val buf = ByteBuffer.wrap(raw)

    buf.putLong(random.nextLong())
    buf.putShort(miniCount.toShort())
    buf.appendBytes(time.toULong() shl 24, 5)

    buf.rewind()

    return Base62.encode(buf.asLongBuffer())
  }

  private fun ByteBuffer.appendBytes(v: ULong, count: Int) {
    if (count > 8)
      throw IllegalArgumentException()
    var mask = 0xFF00000000000000uL

    for (i in 1 .. count) {
      val shift = (8 - i) * 8
      put((((v and mask) shr shift) and 0xFFuL).toUByte().toByte())
      mask = mask shr 8
    }
  }
}